<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	
</body>
<script>
	"use scrict;"
	//Object에 같은 key 사용
	/*(var obj = {key:value})형태에서 key값이 같은 프로퍼티를 두 개 작성했을 때 ES6에서는 strict모드에 관계없이 에러가 발생하지 않으며 나중에 작성된 프로퍼티 값으로 대체됩니다.*/
	function step01() {
		/*Object오브젝트에 프로퍼티 키 값이 one인 프로퍼티를 두 개 작성했으며 콘솔에 {one:2}가 출력됩니다. 첫 번째 one 프로퍼티 값1이 두 번째 프로퍼티 값 2로 대체되었기 때문입니다. 나중에 작성한 프로퍼티는 값만 대체하고 추가되지 않습니다. */
		let sameKey = {one: 1, one: 2};
		console.log(sameKey);
	}

	//변수 이름으로 값 설정
	function step02() {
		/*변수 이름을 사용하여 Object오브젝트의 프로퍼티 값을 설정할 수 있습니다.*/
		/*(let values = {one, two})에서 one이 프로퍼티 이름이 되면서 앞에 작성한 one변수 값이 1이 프로퍼티 값으로 설정됩니다.*/
		let one = 1, two = 2;
		let values = {one, two};
		console.log(values);
	}

	//Object에 function 작성
	function step03(){
		/*ES6에서 Object오브젝트에 함수(메서드)를 다른 방법으로 작성할 수 있습니다. 콜론;과 function키워드를 작성하지 않습니다.*/
		let obj = {
			getTotal(param) {
				return param + 123;
			}
		};
		console.log(obj.getTotal(400));
	}

	//디스크립터
	function step04() {
		//"book"이 프로퍼티 이름입니다.프로퍼티 이름 이외의 {value: 123, enumerable: true}가 프로퍼티 디스크립터입니다.
		Object.defineProperty({}, "book", {
			value: 123,
			enumerable: true
		})
	}

	//프로퍼티 디스크립터 
	/*데이터 프로퍼티 디스크립터 타입(value, writable)과 액세스 디스크립터 타입(get, set)으로 분류됩니다.*/
	/*데이터 타입의 value, writable 속성과 액세스 타입의 get, set 속성을 같이 작성할 수 없습니다. 
	{value: 1, get:function(){}} 형태와 같이 value속성과 get속성을 같이 작성하면 에러가 발생합니다.
	enumerable속성과 configurable속성은 데이터 타입과 액세스 타입에 작성할 수 있습니다.
	*/
	/*프로퍼티 디스크립터에 타입을 별도로 작성하지 않고 속성으로 데이터 타입과 엑세스 타입을 구분합니다. 먼저 value 또는 writable 속성의 작성 여부를 체크합니다. 이를 작성하면 데이터 프로퍼티 디스크립터이고 작성하지 않으면 프로퍼티 디스크립터입니다.*/

	//속성기능
	/**/
	step04();

</script>
</html>